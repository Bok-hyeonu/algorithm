# DP로 1부터 하나씩 올려가며 진행
# 수가 2로 나누어지는 경우, 현재 연산횟수와 현재 값의 1/2에 해당하는 수의 연산횟수 + 1과 비교 진행
# 최솟값을 갱신하는 형태로 동작
N = int(input())
d = [0]*int(N+1) # 연산횟수를 저장할 리스트
for i in range(2, N + 1):
    # 현재 수에서 1을 빼는 경우
    d[i] = d[i-1]+1
    # 현재 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i//2] + 1)
    # 현재 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i//3]+1)
print(d[-1]) # 마지막 결과 출력