# 11054. 가장 긴 바이토닉 부분 수열 

# 1. 첫 번째 원소부터 순회하며 해당 원소의 다음 원소부터 마지막 원소까지
# 2. 첫 번째 원소보다 큰 원소에 대해 가장 긴 부분 수열인지 확인 후 갱신
# 3. 1, 2번을 N번째 원소까지 반복
# 4. 마지막 원소부터 순회하며 해당 원소의 이전 원소부터 첫 원소까지
# 5. 마지막 원소보다 큰 원소에 대해 가장 긴 부분 수열인지 확인 후 갱신
# 6. 4, 5번을 첫 번째 원소까지 반복
# 7. 즉, 1~3번은 i번째 원소를 종점으로 하는 가장 긴 증가하는 부분 수열을
# 4~6번은 i번째 원소를 시점으로 하는 가장 긴 감소하는 부분 수열을 구하는 것
# 8. i번째 수를 기준으로 하는 두 부분 수열의 길이의 최댓값 - 1이 
# 9. 가장 긴 바이토닉 부분 수열의 길이이다.

N = int(input())
nums = list(map(int, input().split()))

# 가장 긴 증가하는 부분 수열
DPinc = [1]*(N)    # i번째 원소를 마지막으로 하는 가장 긴 증가하는 부분 수열

# N개의 원소를 순회하며
for i in range(N):
    for j in range(i+1, N):
        # j번째 원소가 i번째 원소보다 크다면
        if nums[i] < nums[j]:
            # j번째 원소까지의 수열의 길이가 i번째 수열의 길이 이하인 경우
            if DPinc[i] >= DPinc[j]:
                DPinc[j] = DPinc[i] + 1   # 부분 수열 길이 갱신

# 가장 긴 감소하는 부분 수열
DPdec = [1]*(N) # i번째 원소를 시점으로 하는 가장 긴 감소하는 부분수열 길이 저장

# N개의 원소를 마지막에서부터 순회하며
for i in range(N-1, -1, -1):
    for j in range(i - 1, -1, -1):
        # j번째 원소가 i번째 원소보다 크다면 
        if nums[i] < nums[j]:
            # j번째 원소까지의 수열의 길이가 i번째 수열의 길이 이하인 경우
            if DPdec[i] >= DPdec[j]:
                DPdec[j] = DPdec[i] + 1     # 부분 수열 길이 갱신

# 바이토닉 수열의 길이 구하기
# i번째 원소를 마지막으로 하는 증가하는 부분 수열의 길이
# i번째 원소를 시작으로 하는 감소하는 부분 수열의 길이
max_length = 1
for i in range(N):
    max_length = max(max_length, DPinc[i] + DPdec[i] - 1)

print(max_length)