# 어떤 탑에 대해 해당 탑의 신호를 받은 탑이 존재하는 경우
# 어떤 탑의 상태를 송신 완료라 표현하겠다.
# 현재 탑이 송신완료하기 위해서는 현재 탑의 높이보다 큰 탑이
# 현재 탑보다 높은 위치에 존재해야 한다.
# 앞의 탑이 현재 탑의 높이보다 낮거나 같으면 현재 탑보다 먼저 신호를 송신완료할 것이고,
# 높으면 현재 탑의 높이를 수신할 것이다. 따라서, 다음과 같이 풀이하였다.
N = int(input()) # 수
heis = list(map(int, input().split()))
stack = [0]*N # 탑의 높이를 저장할 스택
stack1 = [0]*N # 탑의 위치를 저장할 스택
result = [0]*N # 신호를 수신하는 탑 리스트
top = -1 # 스택 조절 인자

for i in range(N-1, -1, -1): # 맨 뒤 탑부터 탐색
    # 이전의 모든 탑들의 상태가 송신완료이면
    # 즉, 현재 탑이 수신할 신호가 없으면
    # 현재 탑의 높이와 위치를 저장(현재 탑의 신호를 받을 탑을 찾아야 함)
    if top == -1: 
        top += 1
        stack[top] = heis[i] # 높이
        stack1[top] = i # 위치 저장
    # 송신완료하지 못한 탑이 존재하는 경우
    else: 
        # 현재 탑의 높이와 이전의 가장 낮은 탑 높이를 비교해서
        # 현재 탑의 높이가 작거나 같은 경우(현재 탑이 그 어떤 신호도 수신할 수 없는 경우)
        # 현재 탑의 높이와 위치를 저장
        if stack[top] >= heis[i]: 
            top += 1
            stack[top] = heis[i] # 높이 저장
            stack1[top] = i # 위치 저장
        # 현재 탑의 높이가 큰 경우(현재 탑이 수신할 신호가 존재하는 경우)
        else: 
            # 현재 탑이 수신할 신호가 계속 존재하는 동안
            # 높이가 현재 탑이 커야하며, 송신완료하지 못한 탑이 남아 있어야 한다.
            while stack[top] < heis[i] and top >= 0: 
                result[stack1[top]] = i+1 # 현재 탑의 위치를 표시
                top -= 1 # 다음에 비교할 그 뒤의 탑
            # 현재 위치의 신호를 수신할 탑을 찾아야 함
            top += 1 
            stack[top] = heis[i] # 높이
            stack1[top] = i # 위치 저장

print(*result) # 신호를 수신한 탑 리스트 출력