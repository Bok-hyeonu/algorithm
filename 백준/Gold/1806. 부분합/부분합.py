# 1806. 부분합

# 1. 좌측 포인터와 우측 포인터, 누적합을 설정한다.
# 인덱스가 좌측 포인터 이상 우측 포인터 미만인 경우의 부분합을 계산한다.
# 좌측 포인터와 우측 포인터가 같으면 부분합이 0이다.
# 2. 다음의 과정을 우측 포인터가 마지막 인덱스를 지났고, 부분합이 S 미만 을 만족할 때까지 반복한다.
# - 부분합이 S 이상인 경우 : 최소 길이 갱신 및 좌측 포인터 우측 1칸 이동
# - 부분합이 S 미만이면서 우측 포인터가 마지막 지점에 다다르지 않은 경우 : 우측 포인터 우측으로 이동
# 3. 부분합이 S 이상인 경우를 찾지 못했다면 0을 출력하고, 아닌 경우 최소 길이를 출력한다. 

N, S = map(int, input().split())        # 수열의 길이와 부분합
nums = list(map(int, input().split()))  # 수열

l, r = 0, 0 # 좌우 포인터
total = 0   # 누적합
min_length = 100001 # 최소 길이

while True:
  # 부분 합이 S 이상이면
  if total >= S:
    # 최소 길이 갱신
    min_length = min(min_length, r - l)
    total -= nums[l]  # 좌측 포인터 우측으로 한 칸 이동
    l += 1
  # 마지막 지점에 다다른 경우(부분합이 S 미만이면서)
  elif r == N :
    break
  # 부분합이 S 미만이면서 마지막 지점에 다다르지 않은 경우
  else:
    total += nums[r]
    r += 1

# 부분합이 S 이상인 경우를 찾지 못한 경우
if min_length == 100001:
  print(0)
else :
  print(min_length)